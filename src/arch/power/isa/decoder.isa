// -*- mode:c++ -*-

// Copyright (c) 2009 The University of Edinburgh
// Copyright (c) 2021 IBM Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////
//
// The actual Power ISA decoder
// ------------------------------
//
// Power ISA v3.0B has been used for instruction formats, opcode numbers,
// opcode field names, register names, etc.
//
decode PO default Unknown::unknown() {

    format IntImmTrapOp {
        2: tdi({{ Ra }});
        3: twi({{ Ra_sw }});
    }

    4: decode VA_XO {

        // Arithmetic instructions that use source registers Ra, Rb and Rc,
        // with destination register Rt.
        format IntArithOp {
            48: maddhd({{
                int64_t res;
                std::tie(std::ignore, res) = multiplyAdd(Ra_sd, Rb_sd, Rc_sd);
                Rt = res;
            }});

            49: maddhdu({{
                uint64_t res;
                std::tie(std::ignore, res) = multiplyAdd(Ra, Rb, Rc);
                Rt = res;
            }});

            51: maddld({{
                uint64_t res;
                std::tie(res, std::ignore) = multiplyAdd(Ra_sd, Rb_sd, Rc_sd);
                Rt = res;
            }});
        }

        ##include "vector/integer/integer_va_xo.isa"
        ##include "vector/permute_formatting/perm_va_xo.isa"
        ##include "vector/permute_formatting/shift_va_xo.isa"
        ##include "vector/floating/fp_va_xo.isa"
        ##include "vector/exclusive_or_based/permute_exclusive_or_va_xo.isa"

        default: decode VX_XO {
            ##include "vector/integer/integer_vx_xo.isa" 
            ##include "vector/move/vector_regmove.isa"
            ##include "vector/permute_formatting/pack_vx_xo.isa"
            ##include "vector/permute_formatting/unpack_vx_xo.isa"
            ##include "vector/permute_formatting/merge_vx_xo.isa"
            ##include "vector/permute_formatting/splat_vx_xo.isa"
            ##include "vector/permute_formatting/shift_vx_xo.isa"
            ##include "vector/bit_manipulation/bit_vx_xo.isa"
            ##include "vector/floating/fp_vx_xo.isa"
            ##include "vector/exclusive_or_based/polynomial_vx_xo.isa"
            ##include "vector/exclusive_or_based/aes_vx_xo.isa"
            ##include "vector/exclusive_or_based/sha_sigma_vx_xo.isa"
            // ###4: decode VX_XO IntArithOp###
            
            default:decode VC_XO {
                ##include "vector/integer/cmp_vc_xo.isa"
				##include "vector/floating/cmp_vc_xo.isa"
                // These instructions are of VX form and use bits 23 - 31 as XO.
                default: decode VX_8XO {        

                    ##include "vector/bcd/bcd_vx_8xo.isa"
                    ##include "vector/bcd/bcd_num_385.isa"

                }
			}
        }
    }

    format IntImmArithOp {
        7: mulli({{
            int64_t res = Ra_sd * si;
            Rt = res;
        }});

        8: subfic({{
            uint64_t src = ~Ra;
            Rt = src + si + 1;
        }}, true);
    }

    10: IntImmCompLogicOp::cmpli({{
        if (l)
            cr = makeCRFieldUnsigned(Ra, ui, xer.so);
        else
            cr = makeCRFieldUnsigned((uint32_t) Ra, ui, xer.so);
    }});

    11: IntImmCompOp::cmpi({{
        if (l)
            cr = makeCRFieldSigned(Ra, si, xer.so);
        else
            cr = makeCRFieldSigned((int32_t) Ra, si, xer.so);
    }});

    format IntImmArithOp {
        12: addic({{
            uint64_t src = Ra;
            Rt = src + si;
        }}, true);

        13: addic_({{
            uint64_t src = Ra;
            Rt = src + si;
        }}, true, true);
    }

    format IntImmArithCheckRaOp {
        14: addi({{ Rt = Ra + si; }},
                 {{ Rt = si }});

        15: addis({{ Rt = Ra + (si << 16); }},
                  {{ Rt = si << 16; }});
    }

    // Conditionally branch to a PC-relative or absoulute address based
    // on CR and CTR.
    16: BranchDispCondOp::bc({{ NIA = CIA + bd; }},
                             {{ NIA = bd; }});

    17: IntOp::sc({{
        if (FullSystem) {
            fault= std::make_shared<SystemCallInterrupt>();
        } else {
            return std::make_shared<SESyscallFault>(); 
        }
    }}, [ IsSyscall, IsNonSpeculative, IsSerializeAfter ]);

    // Unconditionally branch to a PC-relative or absoulute address.
    18: BranchOp::b({{ NIA = CIA + li; }},
                    {{ NIA = li; }});

    19: decode XL_XO {

        0: CondMoveOp::mcrf({{
            uint32_t crBfa = bits(CR, 31 - bfa*4, 28 - bfa*4);
            CR = insertBits(CR, 31 - bf*4, 28 - bf*4, crBfa);
        }});

        // Conditionally branch to address in LR based on CR and CTR.
        16: BranchRegCondOp::bclr({{ NIA = LR & -4ULL; }}, true, [ IsReturn ]);

        format CondLogicOp {
            33: crnor({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, !(crBa | crBb));
            }});

            129: crandc({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa & !crBb);
            }});
        }

        150: MiscOp::isync({{ }}, [ IsSerializeAfter ]);

        18:  MiscOp::rfid({{
            uint32_t msr12=(bits(MSR,60)&bits(SRR1,12))
                            |((bits(MSR,60)^0x01)&bits(MSR,12));
            MSR = insertBits(MSR,12,msr12);
            uint32_t msr60=bits(MSR,60)&bits(SRR1,60);
            MSR = insertBits(MSR,60,msr60);
            if((bits(MSR,34,32)!=0x02)|(bits(SRR1,34,32)!=0x00))
                MSR = insertBits(MSR,34,32,bits(SRR1,34,32));
            MSR = insertBits(MSR,15,(bits(SRR1,15)|bits(SRR1,14)));
            MSR = insertBits(MSR,5,(bits(SRR1,5)|bits(SRR1,14)));
            MSR = insertBits(MSR,4,(bits(SRR1,4)|bits(SRR1,14)));
            MSR = insertBits(MSR,63,61,bits(SRR1,63,61));
            MSR = insertBits(MSR,59,35,bits(SRR1,59,35));
            MSR = insertBits(MSR,31,bits(SRR1,31));
            MSR = insertBits(MSR,26,22,bits(SRR1,26,22));
            MSR = insertBits(MSR,14,13,bits(SRR1,14,13));
            MSR = insertBits(MSR,11,6,bits(SRR1,11,6));
            MSR = insertBits(MSR,3,0,bits(SRR1,3,0));
            CFAR = CIA;
            NIA = SRR0 & -4ULL;
        }}, [ IsPrivileged, IsNonSpeculative, IsSerializeAfter ]);
        274:  MiscOp::hrfid({{
            if((bits(MSR,34,32)!=0x02)|(bits(HSRR1,34,32)!=0x00))
                MSR = insertBits(MSR,34,32,bits(HSRR1,34,32));
            MSR = insertBits(MSR,15,(bits(HSRR1,15)|bits(HSRR1,14)));
            MSR = insertBits(MSR,5,(bits(HSRR1,5)|bits(HSRR1,14)));
            MSR = insertBits(MSR,4,(bits(HSRR1,4)|bits(HSRR1,14)));
            MSR = insertBits(MSR,63,35,bits(HSRR1,63,35));
            MSR = insertBits(MSR,31,bits(HSRR1,31));
            MSR = insertBits(MSR,26,22,bits(HSRR1,26,22));
            MSR = insertBits(MSR,14,6,bits(HSRR1,14,6));
            MSR = insertBits(MSR,3,0,bits(HSRR1,3,0));
            NIA = HSRR0 & -4ULL;
        }}, [ IsNonSpeculative, IsSerializeAfter ]);

        format CondLogicOp {
            193: crxor({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa ^ crBb);
            }});

            255: crnand({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, !(crBa & crBb));
            }});

            257: crand({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa & crBb);
            }});

            289: creqv({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa == crBb);
            }});

            417: crorc({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa | !crBb);
            }});

            449: cror({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa | crBb);
            }});
        }

        // Conditionally branch to an address in a register based on
        // either CR only or both CR and CTR.
        format BranchRegCondOp {
            528: bcctr({{ NIA = CTR & -4ULL; CFAR = CIA; }});
            560: bctar({{ NIA = TAR & -4ULL; CFAR = CIA; }}, true);
        }

        402: IntArithOp::doze({{ PMC6 = 1; }});
        434: IntArithOp::nap({{ PMC6 = 1; }});
        466: IntArithOp::sleep({{ PMC6 = 1; }});
        498: IntArithOp::rvwinkle({{ PMC6 = 1; }});

        default: decode DX_XO {
            2: IntDispArithOp::addpcis({{ Rt = NIA + (d << 16); }});
        }
    }

    format IntRotateOp {
        21: rlwinm({{
            uint64_t res;
            res = rotate(Rs, sh);
            res = res & bitmask(mb, me);
            Ra = res;
        }});

        23: rlwnm({{
            uint64_t res;
            res = rotate(Rs, Rb);
            res = res & bitmask(mb, me);
            Ra = res;
        }});

        20: rlwimi({{
            uint64_t res, mask;
            mask = bitmask(mb, me);
            res = rotate(Rs, sh);
            res = (res & mask) | (Ra & ~mask);
            Ra = res;
        }});
    }

    format IntImmLogicOp {
        24: ori({{ Ra = Rs | ui; }});
        25: oris({{ Ra = Rs | (ui << 16); }});
        26: xori({{ Ra = Rs ^ ui; }});
        27: xoris({{ Ra = Rs ^ (ui << 16); }});
        28: andi_({{ Ra = Rs & ui; }}, true);
        29: andis_({{ Ra = Rs & (ui << 16); }}, true);
    }

    // These instructions are of MD form and use bits 27 - 29 as XO.
    30: decode MD_XO {
        format IntConcatRotateOp {
            0: rldicl({{
                uint64_t res;
                if (sh != 0) {
                    res = rotate(Rs, sh);
                } else {
                    res = Rs;
                }
                res = res & bitmask(mb, 63);
                Ra = res;
            }});

            1: rldicr({{
                uint64_t res;
                if (sh != 0) {
                    res = rotate(Rs, sh);
                } else {
                    res = Rs;
                }
                res = res & bitmask(0, me);
                Ra = res;
            }});

            2: rldic({{
                uint64_t res;
                if (sh != 0) {
                    res = rotate(Rs, sh);
                } else {
                    res = Rs;
                }
                res = res & bitmask(mb, ~sh);
                Ra = res;
            }});

            3: rldimi({{
                uint64_t res, mask;
                mask = bitmask(mb, ~sh);
                if (sh != 0) {
                    res = rotate(Rs, sh);
                } else {
                    res = Rs;
                }
                res = res & mask;
                res = res | (Ra & ~mask);
                Ra = res;
            }});

            // These instructions are of MDS form and use bits 27 - 30 as XO.
            default: decode MDS_XO {
                8: rldcl({{
                    uint64_t res;
                    uint32_t shift = Rb & 0x3f;
                    if (shift != 0) {
                        res = rotate(Rs, shift);
                    } else {
                        res = Rs;
                    }
                    res = res & bitmask(mb, 63);
                    Ra = res;
                }});

                9: rldcr({{
                    uint64_t res;
                    uint32_t shift = Rb & 0x3f;
                    if (shift != 0) {
                        res = rotate(Rs, shift);
                    } else {
                        res = Rs;
                    }
                    res = res & bitmask(0, me);
                    Ra = res;
                }});
            }
        }
    }

    // There are a large number of instructions that have the same primary
    // opcode (PO) of 31. In this case, the instructions are of different
    // forms. For every form, the XO fields may vary in position and width.
    // The X, XFL, XFX and XL form instructions use bits 21 - 30 and the
    // XO form instructions use bits 22 - 30 as extended opcode (XO). To
    // avoid conflicts, instructions of each form have to be defined under
    // separate decode blocks. However, only a single decode block can be
    // associated with a particular PO and it will recognize only one type
    // of XO field. A solution for associating decode blocks for the other
    // types of XO fields with the same PO is to have the other blocks as
    // nested default cases.
    31: decode X_XO {

        0: IntCompOp::cmp({{
            if (l)
                cr = makeCRFieldSigned(Ra, Rb, xer.so);
            else
                cr = makeCRFieldSigned((int32_t)Ra, (int32_t)Rb, xer.so);
        }});

        4: IntTrapOp::tw({{ Ra_sw }}, {{ Rb_sw }});

        format LoadIndexOp {
            20: lwarx({{ Rt = Mem_uw; Rsv = 1; RsvLen = 4; RsvAddr = EA; }});

            21: ldx({{ Rt = Mem; }});
            23: lwzx({{ Rt = Mem_uw; }});
        }

        24: IntShiftOp::slw({{
            int32_t shift = Rb_sw;
            uint32_t res = Rs_uw & ~((shift << 26) >> 31);
            if (shift != 0) {
                shift = bits(shift, 4, 0);
                res = res << shift;
            }
            Ra = res;
        }});

        26: IntLogicOp::cntlzw({{ Ra = findLeadingZeros(Rs_uw); }}, true);

        27: IntConcatShiftOp::sld({{
            int64_t shift = Rb_sd;
            uint64_t res = Rs & ~((shift << 57) >> 63);
            if (shift != 0) {
                shift = bits(shift, 5, 0);
                res = res << shift;
            }
            Ra = res;
        }});

        28: IntLogicOp::and({{ Ra = Rs & Rb; }}, true);

        32: IntCompOp::cmpl({{
            if (l)
                cr = makeCRFieldUnsigned(Ra, Rb, xer.so);
            else
                cr = makeCRFieldUnsigned((uint32_t)Ra, (uint32_t)Rb, xer.so);
        }});

        52: LoadIndexOp::lbarx({{ Rt = Mem_ub; }},
                               {{ Rsv = 1; RsvLen = 1; RsvAddr = EA; }});

        53: LoadIndexUpdateOp::ldux({{ Rt = Mem; }});
        55: LoadIndexUpdateOp::lwzux({{ Rt = Mem_uw; }});

        format IntLogicOp {
            58: cntlzd({{ Ra = findLeadingZeros(Rs); }}, true);
            60: andc({{ Ra = Rs & ~Rb; }}, true);
        }

        68: IntTrapOp::td({{ Ra }}, {{ Rb }});

        format LoadIndexOp {
            84: ldarx({{ Rt = Mem_ud; }},
                      {{ Rsv = 1; RsvLen = 8; RsvAddr = EA; }});

            87: lbzx({{ Rt = Mem_ub; }});

            116: lharx({{ Rt = Mem_uh;}},
                       {{  Rsv = 1; RsvLen = 2; RsvAddr = EA; }});
        }

        119: LoadIndexUpdateOp::lbzux({{ Rt = Mem_ub; }});

        format IntLogicOp {
            122: popcntb({{
                // Based on "Counting bits set, in parallel"
                // from https://graphics.stanford.edu/~seander/bithacks.html
                const uint64_t m1 = 0x5555555555555555ULL;
                const uint64_t m2 = 0x3333333333333333ULL;
                const uint64_t m4 = 0x0f0f0f0f0f0f0f0fULL;
                uint64_t res = Rs;
                res = (res & m1) + ((res >> 1) & m1);
                res = (res & m2) + ((res >> 2) & m2);
                res = (res & m4) + ((res >> 4) & m4);
                Ra = res;
            }});

            124: nor({{ Ra = ~(Rs | Rb); }}, true);
        }

        format StoreIndexOp {
            149: stdx({{ Mem = Rs }});
            150: stwcx({{
                bool store_performed = false;
                if (Rsv) {
                    Mem_uw = Rs_uw;
                    store_performed = true;
                    Rsv = 0;
                }
                Xer xer = XER;
                PowerISA::Cr cr = CR;
                cr.cr0 = ((store_performed ? 0x2 : 0x0) | xer.so);
                CR = cr;
                write_mem = store_performed;
            }});

            151: stwx({{ Mem_uw = Rs_uw; }});
        }

        154: IntLogicOp::prtyw({{
            uint64_t res = Rs;
            res = res ^ (res >> 16);
            res = res ^ (res >> 8);
            res = res & 0x100000001;
            Ra = res;
        }});

        format StoreIndexUpdateOp {
            181: stdux({{ Mem = Rs; }});
            183: stwux({{ Mem_uw = Rs_uw; }});
        }

        186: IntLogicOp::prtyd({{
            uint64_t res = Rs;
            res = res ^ (res >> 32);
            res = res ^ (res >> 16);
            res = res ^ (res >> 8);
            res = res & 0x1;
            Ra = res;
        }});

        192: IntCompOp::cmprb({{
            uint32_t src1 = Ra_ub;
            uint32_t src2 = Rb_uw;
            uint8_t src2lo = src2 & 0xff;
            uint8_t src2hi = (src2 >>= 8) & 0xff;
            uint32_t res = (src2lo <= src1) & (src1 <= src2hi);
            if (l) {
                src2lo = (src2 >>= 8) & 0xff;
                src2hi = (src2 >>= 8) & 0xff;
                res = ((src2lo <= src1) & (src1 <= src2hi)) | res;
            }
            cr = res << 2;
        }});

        format StoreIndexOp {
            214: stdcx({{
                bool store_performed = false;
                if (Rsv) {
                    Mem = Rs;
                    store_performed = true;
                    Rsv = 0;
                }
                Xer xer = XER;
                Cr cr = CR;
                cr.cr0 = ((store_performed ? 0x2 : 0x0) | xer.so);
                CR = cr;
                write_mem = store_performed;
            }});

            215: stbx({{ Mem_ub = Rs_ub; }});
        }

        224: IntCompOp::cmpeqb({{
            // Based on "Determine if a word has a byte equal to n"
            // from https://graphics.stanford.edu/~seander/bithacks.html
            const uint64_t m1 = 0x0101010101010101;
            const uint64_t m2 = 0x8080808080808080;
            uint64_t res = Rb ^ (Ra_ub * m1);
            res = (res - m1) & ~res & m2;
            cr = (res != 0) << 2;
        }});

        //246: MiscOp::dcbtst({{ }});
        247: StoreIndexUpdateOp::stbux({{ Mem_ub = Rs_ub; }});

        252: IntLogicOp::bpermd({{
            uint64_t res = 0;
            for (int i = 0; i < 8; ++i) {
                int index = (Rs >> (i * 8)) & 0xff;
                if ((index < 64) && bits(Rb, 63 - index)) {
                        res |= 1 << i;
                }
            }
            Ra = res;
        }});

        format IntArithOp {
            265: modud({{
                uint64_t src1 = Ra;
                uint64_t src2 = Rb;
                if (src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});

            267: moduw({{
                uint64_t src1 = Ra_uw;
                uint64_t src2 = Rb_uw;
                if (src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});

            //TODO: Right now we doesn't support DARN instruction
            // Not returning random number, Just Setting value to -1.
            //Need to FIX that instruction

            755: darn({{
                  Rt = -1;
            }});

        }

        //278: MiscOp::dcbt({{ }});
        279: LoadIndexOp::lhzx({{ Rt = Mem_uh; }});
        284: IntLogicOp::eqv({{ Ra = ~(Rs ^ Rb); }}, true);
        311: LoadIndexUpdateOp::lhzux({{ Rt = Mem_uh; }});
        316: IntLogicOp::xor({{ Ra = Rs ^ Rb; }}, true);

        format LoadIndexOp {
            341: lwax({{ Rt = Mem_sw; }});
            343: lhax({{ Rt = Mem_sh; }});
        }

        format LoadIndexUpdateOp {
            373: lwaux({{ Rt = Mem_sw; }});
            375: lhaux({{ Rt = Mem_sh; }});
        }

        342: MiscOp::dst({{ }});
        374: MiscOp::dstst({{ }});
        822: MiscOp::dss({{ }});

        378: IntLogicOp::popcntw({{
        #if defined(__GNUC__) || (defined(__clang__) && \
                __has_builtin(__builtin_popcount))
            uint64_t src = Rs;
            uint64_t res = __builtin_popcount(src >> 32);
            res = (res << 32) | __builtin_popcount(src);
        #else
            // Based on "Counting bits set, in parallel"
            // from https://graphics.stanford.edu/~seander/bithacks.html
            const uint64_t m1 = 0x5555555555555555ULL;
            const uint64_t m2 = 0x3333333333333333ULL;
            const uint64_t m4 = 0x0f0f0f0f0f0f0f0fULL;
            const uint64_t m8 = 0x00ff00ff00ff00ffULL;
            const uint64_t m16 = 0x0000ffff0000ffffULL;
            uint64_t res = Rs;
            res = (res & m1) + ((res >> 1) & m1);
            res = (res & m2) + ((res >> 2) & m2);
            res = (res & m4) + ((res >> 4) & m4);
            res = (res & m8) + ((res >> 8) & m8);
            res = (res & m16) + ((res >> 16) & m16);
        #endif
            Ra = res;
        }});

        407: StoreIndexOp::sthx({{ Mem_uh = Rs_uh; }});
        412: IntLogicOp::orc({{ Ra = Rs | ~Rb; }}, true);
        439: StoreIndexUpdateOp::sthux({{ Mem_uh = Rs_uh; }});

        format IntLogicOp {
            444: or({{ Ra = Rs | Rb; }}, true);
            476: nand({{ Ra = ~(Rs & Rb); }}, true);
            506: popcntd({{ Ra = popCount(Rs); }});

            508: cmpb({{
                uint64_t mask = 0xff;
                uint64_t res = 0;
                for (int i = 0; i < 8; ++i) {
                    if ((Rs & mask) == (Rb & mask)) {
                        res |= mask;
                    }
                    mask <<= 8;
                }
                Ra = res;
            }});
        }

        format LoadIndexOp {
            532: ldbrx({{ Rt = swap_byte(Mem); }});
            534: lwbrx({{ Rt = swap_byte(Mem_uw); }});
            //535: lfsx({{ Ft_sf = Mem_sf; }});
        }

        536: IntShiftOp::srw({{
            int32_t shift = Rb_sw;
            uint32_t res = Rs_uw & ~((shift << 26) >> 31);
            if (shift != 0) {
                shift = bits(shift, 4, 0);
                res = res >> shift;
            }
            Ra = res;
        }});

        538: IntLogicOp::cnttzw({{ Ra = findTrailingZeros(Rs_uw); }}, true);

        539: IntConcatShiftOp::srd({{
            int64_t shift = Rb_sd;
            uint64_t res = Rs & ~((shift << 57) >> 63);
            if (shift != 0) {
                shift = bits(shift, 5, 0);
                res = res >> shift;
            }
            Ra = res;
        }});

        //567: LoadIndexUpdateOp::lfsux({{ Ft_sf = Mem_sf; }});
        570: IntLogicOp::cnttzd({{ Ra = findTrailingZeros(Rs); }}, true);

        576: IntOp::mcrxrx({{
            uint8_t res;
            Xer xer = XER;
            res = (xer.ov << 3) | (xer.ov32 << 2) | (xer.ca << 1) | xer.ca32;
            CR = insertCRField(CR, BF, res);
        }});

        //598: MiscOp::sync({{ }}, [ IsReadBarrier, IsWriteBarrier ]);
        // These instructions all provide data cache hints
        // Right now doesn't have cache support
        format CacheLoadIndexOp {
            278: dcbt({{ Mem; }});
            246: dcbtst({{ Mem; }});
            86: dcbf({{ Mem; }});
            54: dcbst({{ Mem; }});
            982: icbi({{ Mem; }});
        }

        format StoreIndexOp {
            1014: dcbz({{
                  Request::Flags flags = Request::PHYSICAL;
                  Addr EA;
                  if (RA == 0)
                      EA = Rb & -128ULL;
                  else
                    EA = (Ra + Rb) & -128ULL;

                  for (int i = 0; i < 16; ++i) {
                    Mem_cacheline[i] = 0;
                }
            }});
        }

        format MiscOp {
            598: sync({{ }}, [ IsReadBarrier, IsWriteBarrier ]);
            854: eieio({{ }}, [ IsReadBarrier, IsWriteBarrier ]);

            306: tlbie({{ dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->dtb)->walker->slb_table[0];Rb}});
            274: tlbiel({{ }});
            566: tlbsync({{ }});

            434: IntLogicOp::slbie({{
                dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->itb)->walker->slbie_helper(xc->tcBase(), Rb);
                dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->dtb)->walker->slbie_helper(xc->tcBase(), Rb);
            }}, [IsNonSpeculative]);
            498: IntLogicOp::slbia({{
                IH;
                for (int i = 1; i < 64; i++) {
                    dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->itb)->walker->slb_table[i].esid = 0;
                    dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->dtb)->walker->slb_table[i].esid = 0;
                }
            }}, [IsNonSpeculative]);
            402: IntLogicOp::slbmte({{
                int index = Rb & 0x7ff;
                dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->itb)->walker->ppc_store_slb(index, Rb & (~0x7ffULL), Rs);
                dynamic_cast<PowerISA::TLB *>(
                                xc->tcBase()->getMMUPtr()->dtb)->walker->ppc_store_slb(index, Rb & (~0x7ffULL), Rs);
                //printf("slbmte, index = %d ESID = %llx VSID = %llx\n", Rb & 0x7ff, Rb, Rs);
            }}, [IsNonSpeculative]);
            851: IntLogicOp::slbmfev({{ Rt;Rb;}});
            915: IntLogicOp::slbmfee({{ Rt;Rb;}});
            979: IntLogicOp::slbfee({{ Rt;Rb;}});
        }
        //599: LoadIndexOp::lfdx({{ Ft = Mem_df; }});
        //631: LoadIndexUpdateOp::lfdux({{ Ft = Mem_df; }});

        format StoreIndexOp {
            660: stdbrx({{ Mem = swap_byte(Rs); }});
            662: stwbrx({{ Mem_uw = swap_byte(Rs_uw); }});
            //663: stfsx({{ Mem_sf = Fs_sf; }});

            694: stbcx({{
                bool store_performed = false;
                if (Rsv) {
                    Mem_ub = Rs_ub;
                    store_performed = true;
                    Rsv = 0;
                }
                Xer xer = XER;
                Cr cr = CR;
                cr.cr0 = ((store_performed ? 0x2 : 0x0) | xer.so);
                CR = cr;
                write_mem = store_performed;
            }});
        }

        //695: StoreIndexUpdateOp::stfsux({{ Mem_sf = Fs_sf; }});

        format StoreIndexOp {
            726: sthcx({{
                bool store_performed = false;
                if (Rsv) {
                    Mem_uh = Rs_uh;
                    store_performed = true;
                    Rsv = 0;
                }
                Xer xer = XER;
                Cr cr = CR;
                cr.cr0 = ((store_performed ? 0x2 : 0x0) | xer.so);
                CR = cr;
                write_mem = store_performed;
            }});

            //727: stfdx({{ Mem_df = Fs; }});
        }

        //759: StoreIndexUpdateOp::stfdux({{ Mem_df = Fs; }});

        format IntArithOp {
            777: modsd({{
                int64_t src1 = Ra_sd;
                int64_t src2 = Rb_sd;
                if ((src1 != INT64_MIN || src2 != -1) && src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});

            779: modsw({{
                int64_t src1 = Ra_sw;
                int64_t src2 = Rb_sw;
                if ((src1 != INT32_MIN || src2 != -1) && src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});
        }

        790: LoadIndexOp::lhbrx({{ Rt = swap_byte(Mem_uh); }});

        792: IntShiftOp::sraw({{
            int32_t src = Rs_sw;
            uint32_t shift = Rb_uw;
            int64_t res;
            if (bits(shift, 5)) {
                res = src >> 31;
                if (res != 0) {
                    setCA = true;
                }
            } else {
                if (shift != 0) {
                    shift = bits(shift, 4, 0);
                    res = src >> shift;
                    setCA = src < 0 && (src & mask(shift)) != 0;
                } else {
                    res = src;
                }
            }
            Ra = res;
        }}, true);

        794: IntConcatShiftOp::srad({{
            int64_t src = Rs_sd;
            uint64_t shift = Rb;
            int64_t res;
            if (bits(shift, 6)) {
                res = src >> 63;
                setCA = res != 0;
            } else {
                if (shift != 0) {
                    shift = shift & 0x3f;
                    res = src >> shift;
                    setCA = src < 0 && (src & mask(shift)) != 0;
                } else {
                    res = src;
                }
            }
            Ra = res;
        }}, true);

        824: IntShiftOp::srawi({{
            int32_t src = Rs_sw;
            int64_t res;
            if (sh) {
                res = src >> sh;
                setCA = src < 0 && (src & mask(sh)) != 0;
            } else {
                res = src;
            }
            Ra = res;
        }}, true);

        //854: MiscOp::eieio({{ }}, [ IsReadBarrier, IsWriteBarrier ]);
        //855: LoadIndexOp::lfiwax({{ Ft_uw = Mem; }});
        918: StoreIndexOp::sthbrx({{ Mem_uh = swap_byte(Rs_uh); }});

        format IntLogicOp {
            922: extsh({{ Ra = Rs_sh; }}, true);
            954: extsb({{ Ra = Rs_sb; }}, true);
        }

        //983: StoreIndexOp::stfiwx({{ Mem = Fs_uw; }});
        986: IntLogicOp::extsw({{ Ra = Rs_sw; }}, true);

        // These instructions are of XO form with bit 21 as the OE bit.
        default: decode XO_XO {
            8: IntSumOp::subfc({{ ~Ra }}, {{ Rb }}, {{ 1 }}, true);

            9: IntArithCheckRcOp::mulhdu({{
                uint64_t res;
                std::tie(std::ignore, res) = multiply(Ra, Rb);
                Rt = res;
            }});

            10: IntSumOp::addc({{ Ra }}, {{ Rb }}, computeCA = true);

            11: IntArithCheckRcOp::mulhwu({{
                uint64_t res = (uint64_t)Ra_uw * Rb_uw;
                res = res >> 32;
                Rt = res;
            }});

            40: IntSumOp::subf({{ ~Ra }}, {{ Rb }}, {{ 1 }});

            format IntArithCheckRcOp {
                73: mulhd({{
                    int64_t res;
                    std::tie(std::ignore, res) = multiply(Ra_sd, Rb_sd);
                    Rt = res;
                }});

                75: mulhw({{
                    uint64_t res = (int64_t)Ra_sw * Rb_sw;
                    res = res >> 32;
                    Rt = res;
                }});
            }

            format IntSumOp {
                104: neg({{ ~Ra }}, {{ 1 }});
                136: subfe({{ ~Ra }}, {{ Rb }}, {{ xer.ca }}, true);
                138: adde({{ Ra }}, {{ Rb }}, {{ xer.ca }}, true);
                200: subfze({{ ~Ra }}, {{ xer.ca }}, computeCA = true);
                202: addze({{ Ra }}, {{ xer.ca }}, computeCA = true);
                232: subfme({{ ~Ra }}, {{ -1ULL }}, {{ xer.ca }}, true);
                234: addme({{ Ra }}, {{ -1ULL }}, {{ xer.ca }}, true);
            }

            format IntArithCheckRcOp {
                233: mulld({{
                    int64_t src1 = Ra_sd;
                    int64_t src2 = Rb_sd;
                    uint64_t res = src1 * src2;
                    std::tie(res, std::ignore) = multiply(src1, src2);
                    if (src1 != 0 && (int64_t)res / src1 != src2) {
                        setOV = true;
                    }
                    Rt = res;
                }}, true);

                235: mullw({{
                    int64_t res = (int64_t)Ra_sw * Rb_sw;
                    if (res != (int32_t)res) {
                        setOV = true;
                    }
                    Rt = res;
                }}, true);
            }

            266: IntSumOp::add({{ Ra }}, {{ Rb }});

            format IntArithCheckRcOp {
                393: divdeu({{
                    uint64_t src1 = Ra;
                    uint64_t src2 = Rb;
                    uint64_t res;
                    std::tie(setOV, res, std::ignore) = divide(0, src1, src2);
                    if (!setOV) {
                        Rt = res;
                    } else {
                        Rt = 0;
                    }
                }}, true);

                395: divweu({{
                    uint32_t src1 = Ra_ud;
                    uint32_t src2 = Rb_ud;
                    uint64_t res;
                    if (src2 != 0) {
                        res = ((uint64_t)src1 << 32) / src2;
                        if (res <= UINT32_MAX) {
                            Rt = (uint32_t)res;
                        } else {
                            Rt = 0;
                            setOV = true;
                        }
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }}, true);

                425: divde({{
                    int64_t src1 = Ra_sd;
                    int64_t src2 = Rb_sd;
                    int64_t res;
                    std::tie(setOV, res, std::ignore) = divide(0, src1, src2);
                    if (!setOV) {
                        Rt = res;
                    } else {
                        Rt = 0;
                    }
                }}, true);

                427: divwe({{
                    int32_t src1 = Ra_sw;
                    int32_t src2 = Rb_sw;
                    int64_t res;
                    if ((src1 != INT32_MIN || src2 != -1) && src2 != 0) {
                        res = ((int64_t)src1 << 32) / src2;
                        if (res == (int32_t)res) {
                            Rt = (uint32_t)res;
                        } else {
                            Rt = 0;
                            setOV = true;
                        }
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }}, true);

                457: divdu({{
                    uint64_t src1 = Ra;
                    uint64_t src2 = Rb;
                    if (src2 != 0) {
                        Rt = src1 / src2;
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }}, true);

                459: divwu({{
                    uint32_t src1 = Ra_uw;
                    uint32_t src2 = Rb_uw;
                    if (src2 != 0) {
                        Rt = src1 / src2;
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }}, true);

                489: divd({{
                    int64_t src1 = Ra_sd;
                    int64_t src2 = Rb_sd;
                    if ((src1 != INT64_MIN || src2 != -1) && src2 != 0) {
                        Rt = src1 / src2;
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }}, true);

                491: divw({{
                    int32_t src1 = Ra_sw;
                    int32_t src2 = Rb_sw;
                    if ((src1 != INT32_MIN || src2 != -1) && src2 != 0) {
                        Rt = (uint32_t)(src1 / src2);
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }}, true);
            }

            // These instructions are of XS form and use bits 21 - 29 as XO.
            default: decode XS_XO {
                format IntConcatShiftOp {
                    413: sradi({{
                        int64_t src = Rs_sd;
                        if (sh != 0) {
                            Ra = src >> sh;
                            if (src < 0 && (src & mask(sh))) {
                                setCA = true;
                            }
                        } else {
                            Ra = src;
                        }
                    }}, true);

                    445: extswsli({{
                        int64_t src = Rs_sw;
                        if (sh != 0) {
                            Ra = src << sh;
                        } else {
                            Ra = src;
                        }
                    }});
                }

                default: decode XFX_XO {
                    format IntOp {
                        19: decode S {
                            0: mfcr({{ Rt = CR; }});

                            1: mfocrf({{
                                int count = popCount(FXM);
                                uint64_t mask = 0xf << (4 * findMsbSet(FXM));
                                if (count == 1) {
                                    Rt = CR & mask;
                                }
                            }});
                        }

                        144: decode S {
                            0: mtcrf({{
                                uint32_t mask = 0;
                                for (int i = 0; i < 8; ++i) {
                                    if (bits(FXM, i)) {
                                        mask |= 0xf << (4 * i);
                                    }
                                }
                                CR = (Rs & mask) | (CR & ~mask);
                            }});

                            1: mtocrf({{
                                int count = popCount(FXM);
                                uint32_t mask = 0xf << (4 * findMsbSet(FXM));
                                if (count == 1) {
                                    CR = (Rs & mask) | (CR & ~mask);
                                }
                            }});
                        }

                        512: mcrxr({{
                            CR = insertCRField(CR, BF, XER<31:28>);
                            XER = XER<27:0>;
                        }});
                    }
                }
            }
        }

        ##include "fp/storage_access/fp_load.isa"
        ##include "fp/storage_access/fp_load_i_update.isa"
        ##include "vector/storage_access/vector_load.isa"
        ##include "vsx/storage_access/vsx_load.isa"

        ##include "fp/storage_access/fp_store.isa"
        ##include "fp/storage_access/fp_store_i_update.isa"
        ##include "vector/storage_access/vector_store.isa"
        ##include "vsx/storage_access/vsx_store.isa"

        ##include "vsx/move/vsx_regmove.isa"

        // Generic integer format instructions.
        format IntOp {
            339: decode SPR {
                0x004: mftfhar({{ Rt = TFHAR; }});
                0x008: mfvrsave({{ Rt = VRSAVE; }});
                0x018: mfsier({{Rt = SIER;}});
                0x019: mfbescrs({{Rt = BESCRS;}});
                0x01C: mfppr({{ Rt = PPR; }});
                0x020: mfxer({{ Rt = XER; }});
                0x024: mftfiar({{ Rt = TFIAR; }});
                0x039: mfbescrsu({{Rt = BESCRSU;}});
                0x044: mftexasr({{ Rt = TEXASR; }});
                0x05C: mfppr2({{ Rt =PPR32; }});
                0x078: mfupmc1({{Rt = PMC1;}});
                0x098: mfupmc2({{Rt = PMC2;}});
                0x099: mfebbhr({{Rt = EBBHR;}});
                0x0b8: mfupmc3({{Rt = PMC3;}});
                0x0b9: mfebbrr({{Rt = EBBRR;}});
                0x0d8: mfupmc4({{Rt = PMC4;}});
                0x0d9: mfbescr({{Rt = BESCR;}});
                0x0f8: mfupmc5({{Rt = PMC5;}});
                0x100: mflr({{ Rt = LR; }});
                0x104: mfctrl({{ Rt = CTRL; }});
                0x118: mfupmc6r({{Rt = PMC6;}});
                0x120: mfctr({{ Rt = CTR; }});
                0x188: mftb({{
                    auto ic = dynamic_cast<PowerISA::Interrupts *>(
                    xc->tcBase()->getCpuPtr()->getInterruptController(0));
                    TB = ic->timebase_counter;
                    Rt = TB;
                }});
                0x1A8: mftbu({{ Rt = TBU; }});
                0x1b8: mfsdar({{Rt = SDAR; }});
                0x1f9: mftar({{Rt = TAR;}});
                0x204: mftidr({{ Rt = TIDR; }}, [ IsPrivileged ]);
                0x205: mfdpdes({{ Rt = DPDES; }}, [ IsPrivileged ]);
                0x208: mfsprg0({{Rt = SPRG0;}});
                0x209: mfhsprg0({{Rt = HSPRG0;}});
                0x20a: mfhmer({{Rt = HMER;}});
                0x20E: mfptcr({{ Rt = PTCR; }});
                0x219: mfasdr({{Rt = ASDR;}});
                0x21a: mfic({{Rt = IC;}}, [ IsPrivileged ]);
                0x21f: mfhir0({{Rt = HIR0;}});
                0x220: mfdscr({{ Rt = DSCR; }});
                0x228: mfsprg1({{Rt = SPRG1;}});
                0x229: mfhsprg1({{Rt = HSPRG1;}});
                0x22a: mfhmeer({{Rt = HMEER;}});
                0x23a: mfvtb({{Rt = VTB;}}, [ IsPrivileged ]);
                0x240: mfdsisr({{ Rt = DSISR; }});
                0x248: mfsprg2({{Rt = SPRG2;}});
                0x249: mfhdisr({{Rt = HDSISR;}});
                0x24a: mfpcr({{Rt = PCR;}});
                0x260: mfdar({{ Rt = DAR; }});
                0x268: mfsprg3({{Rt = SPRG3;}});
                0x269: mfhdar({{Rt = HDAR;}});
                0x285: mfdawr0({{ Rt = DAWR0; }});
                0x289: mfspurr({{Rt = SPURR;}}, [ IsPrivileged ]);
                0x2a9: mfpurr({{Rt = PURR;}}, [ IsPrivileged ]);
                0x2C0: mfdec({{
                    auto ic = dynamic_cast<PowerISA::Interrupts *>(
                    xc->tcBase()->getCpuPtr()->getInterruptController(0));
                    DEC = ic->decrement_counter;
                    Rt = DEC;
                }});
                0x2c9: mfhdec({{Rt = HDEC;}});
                0x2fa: mfpsscr({{Rt = PSSCR;}});
                0x320: mfsdr1({{Rt = SDAR; }});
                0x324: mffscr({{Rt = FSCR;}});
                0x329: mfhrmor({{Rt = HRMOR;}});
                0x340: mfsrr0({{ Rt = SRR0; }});
                0x345: mfrpr({{ Rt = RPR; }});
                0x349: mfhssr0({{Rt = HSRR0;}});
                0x360: mfsrr1({{ Rt = SRR1; }});
                0x365: mfciabr({{ Rt = CIABR; }});
                0x368: mfcir({{Rt = CIR;}}, [ IsPrivileged ]);
                0x369: mfhssr1({{Rt = HSRR1;}});
                0x380: mfcfar({{ Rt = CFAR; }});
                0x3a0: mfamr({{ Rt = AMR; }}, [ IsPrivileged ]);
                0x3a1: mfiamr({{Rt = IAMR;}});
                0x3a4: mfuamor({{ Rt = UAMOR; }}, [ IsPrivileged ]);
                0x3aa: mfamor({{Rt = AMOR;}});
                0x3a9: mfspr({{ }});
                0x3c5: mfhfscr({{Rt = HFSCR;}});
                0x3c9: mflpcr({{Rt = LPCR;}});
                0x3E8: mfpvr({{ Rt = PVR; }});
                0x3e9: mflpidr({{Rt = LPIDR;}});
                0x3ff: mfpir({{ Rt = PIR;}}, [ IsPrivileged ]);

                0x218: mfspr218({{ }});
                0x238: mfmmcr2({{Rt = MMCR2;}});
                0x378: mfmmcr0({{Rt = MMCR0;}});
                0x398: mfspr398({{ }});
                0x3b8: mfspr3b8({{ }});
            }
            467: decode SPR {
                0x004: mttfhar({{TFHAR = Rs;}});
                0x008: mtvrsave({{ VRSAVE = Rs; }});
                0x019: mtbescrs({{BESCRS = Rs;}});
                0x01C: mtppr({{ PPR = Rs; }});
                0x020: mtxer({{ XER = Rs; }});
                0x024: mttfiar({{TFIAR = Rs;}});
                0x039: mtbescrsu({{BESCRSU = Rs;}});
                0x044: mttexasr({{TEXASR = Rs;}});
                0x05C: mtppr32({{ PPR32 = Rs; }});
                0x078: mtupmc1({{PMC1 = Rs;}});
                0x098: mtupmc2({{PMC2 = Rs;}});
                0x099: mtebbhr({{EBBHR = Rs;}});
                0x0b8: mtupmc3({{PMC3 = Rs;}});
                0x0b9: mtebbrr({{EBBRR = Rs;}});
                0x0d8: mtupmc4({{PMC4 = Rs;}});
                0x0d9: mtbescr({{BESCR = Rs;}});
                0x0f8: mtupmc5({{PMC5 = Rs;}});
                0x100: mtlr({{ LR = Rs; }});
                0x118: mtupmc6({{PMC6 = Rs;}});
                0x120: mtctr({{ CTR = Rs; }});
                0x1A8: mttbu({{ TBU = Rs; }});
                0x1f9: mttar({{TAR = Rs;}});
                0x201: mtpidr({{PIDR = Rs;}});
                0x204: mttidr({{TIDR = Rs;}}, [ IsPrivileged ]);
                0x205: mtdpdes({{DPDES = Rs;}});
                0x208: mtsprg0({{SPRG0 = Rs;}});
                0x209: mthsprg0({{HSPRG0 = Rs;}});
                0x20a: mthmer({{HMER = Rs;}});
                0x20E: mtptcr({{ PTCR = Rs; }});
                0x219: mtasdr({{ASDR = Rs; }});
                0x21a: mtic({{IC = Rs;}});
                0x21f: mthir0({{HIR0 = Rs;}});
                0x220: mtdscr({{ DSCR = Rs; }});
                0x228: mtsprg1({{SPRG1 = Rs;}});
                0x229: mthsprg1({{HSPRG1 = Rs;}});
                0x22a: mthmeer({{HMEER = Rs;}});
                0x238: mtmmcr2({{MMCR2 = Rs;}});
                0x23a: mtvtb({{VTB = Rs;}});
                0x240: mtdsisr({{ DSISR = Rs; }});
                0x248: mtsprg2({{SPRG2 = Rs;}});
                0x249: mthdisr({{HDSISR = Rs;}});
                0x24a: mtpcr({{PCR = Rs;}});
                0x258: mtmmcra({{MMCRA = Rs;}});
                0x260: mtdar({{ DAR = Rs; }});
                0x268: mtsprg3({{SPRG3 = Rs;}});
                0x269: mthdar({{HDAR = Rs;}});
                0x27a: mtmmcrc({{MMCRC = Rs;}});
                0x285: mtdawr0({{DAWR0 = Rs;}});
                0x289: mtspurr({{SPURR = Rs;}});
                0x2a9: mtpurr({{PURR = Rs;}});
                0x2C0: mtdec({{
                    auto ic = dynamic_cast<PowerISA::Interrupts *>(
                    xc->tcBase()->getCpuPtr()->getInterruptController(0));
                    ic->decrement_counter = Rs;
                    DEC = Rs;
                }});
                0x2c9: mthdec({{HDEC = Rs;}});
                0x2fa: mtpsscr({{PSSCR = Rs;}});
                0x304: mtctrl({{ CTRL = Rs; }});
                0x324: mtfscr({{FSCR = Rs;}});
                0x329: mthrmor({{HRMOR = Rs;}});
                0x340: mtsrr0({{ SRR0 = Rs; }});
                0x345: mtrpr({{RPR = Rs;}});
                0x349: mthssr0({{HSRR0 = Rs;}});
                0x360: mtsrr1({{ SRR1 = Rs; }});
                0x365: mtciabr({{CIABR = Rs;}});
                0x369: mthssr1({{HSRR1 = Rs;}});
                0x378: mtmmcr0({{MMCR0 = Rs;}});
                0x380: mtcfar({{ CFAR = Rs; }});
                0x390: mttbl({{ TBL = Rs; }});
                0x33c: mtspr({{ }});
                0x3a0: mtamr({{AMR = Rs;}}, [ IsPrivileged ]);
                0x3a1: mtiamr({{IAMR = Rs;}});
                0x3a4: mtuamor({{UAMOR = Rs;}}, [ IsPrivileged ]);
                0x3aa: mtamor({{AMOR = Rs;}});
                0x3c5: mthfscr({{HFSCR = Rs;}});
                0x3c8: mttbu40({{TBU40 = Rs;}});
                0x3c9: mtlpcr({{LPCR = Rs;}});
                0x3d8: mtmmcr1({{MMCR1 = Rs;}});
                0x3e9: mtlpidr({{LPIDR = Rs;}});

                0x218: mtspr218({{ }});
                0x398: mtspr398({{ }});
                0x3b8: mtspr3b8({{ }});

                0x320: mtsdr1({{ SDAR = Rs; }});
                0x389: mtspr389({{ }});
                0x3db: mtspr3db({{ }});
            }

            83: mfmsr({{ Rt = MSR; }}, [ IsPrivileged ]);

            178: mtmsrd({{
                if (L == 0 ) {
                    uint64_t val = bits(Rs, 34, 32);

                     if(bits(MSR, 34, 32) != 0x2 || val != 0x0) {
                      MSR =  insertBits(MSR, 34, 32, val);
                    }

                    val = bits(Rs, 14);

                    MSR = insertBits(MSR,  5,  bits(Rs, 5) | val);
                    MSR = insertBits(MSR,  4,  bits(Rs, 4) | val);

                    MSR = insertBits(MSR, 63, 61, bits(Rs, 63, 61));
                    MSR = insertBits(MSR, 59, 35, bits(Rs, 59, 35));
                    MSR = insertBits(MSR, 31, 16, bits(Rs, 31, 16));
                    MSR = insertBits(MSR, 14, 13, bits(Rs, 14, 13));
                    MSR = insertBits(MSR, 11,  6, bits(Rs, 11,  6));
                    MSR = insertBits(MSR,  3,  1, bits(Rs,  3,  1));
                } else {
                    MSR = insertBits(MSR, 15, bits(Rs, 15));
                    MSR = insertBits(MSR,  1, bits(Rs,  1));
                }
            }}, [ IsPrivileged, IsNonSpeculative, IsSerializeAfter ]);

            146: mtmsr({{
                 if( L ==0 ){
                     MSR = insertBits(MSR,15,bits(Rs,15)|bits(Rs,14));
                     MSR = insertBits(MSR,5,bits(Rs,5)|bits(Rs,14));
                     MSR = insertBits(MSR,4,bits(Rs,4)|bits(Rs,14));
                     MSR = insertBits(MSR,31,16,bits(Rs,31,16));
                     MSR = insertBits(MSR,14,13,bits(Rs,14,13));
                     MSR = insertBits(MSR,11,6,bits(Rs,11,6));
                     MSR = insertBits(MSR,3,1,bits(Rs,3,1));
                 }
                 else{
                     MSR = insertBits(MSR,15,bits(Rs,15));
                     MSR = insertBits(MSR,1,bits(Rs,1));
                 }
            }}, [ IsPrivileged, IsNonSpeculative, IsSerializeAfter ]);
        }
    }

    32: LoadDispOp::lwz({{ Rt = Mem_uw; }});
    33: LoadDispUpdateOp::lwzu({{ Rt = Mem_uw; }});
    34: LoadDispOp::lbz({{ Rt = Mem_ub; }});
    35: LoadDispUpdateOp::lbzu({{ Rt = Mem_ub; }});
    36: StoreDispOp::stw({{ Mem_uw = Rs_uw; }});
    37: StoreDispUpdateOp::stwu({{ Mem_uw = Rs_uw; }});
    38: StoreDispOp::stb({{ Mem_ub = Rs_ub; }});
    39: StoreDispUpdateOp::stbu({{ Mem_ub = Rs_ub; }});
    40: LoadDispOp::lhz({{ Rt = Mem_uh; }});
    41: LoadDispUpdateOp::lhzu({{ Rt = Mem_uh; }});
    42: LoadDispOp::lha({{ Rt = Mem_sh; }});
    43: LoadDispUpdateOp::lhau({{ Rt = Mem_sh; }});
    44: StoreDispOp::sth({{ Mem_uh = Rs_uh; }});
    45: StoreDispUpdateOp::sthu({{ Mem_uh = Rs_uh; }});
    //48: LoadDispOp::lfs({{ Ft_sf = Mem_sf; }});
    //49: LoadDispUpdateOp::lfsu({{ Ft_sf = Mem_sf; }});
    //50: LoadDispOp::lfd({{ Ft = Mem_df; }});
    //51: LoadDispUpdateOp::lfdu({{ Ft = Mem_df; }});
    //52: StoreDispOp::stfs({{ Mem_sf = Fs_sf; }});
    //53: StoreDispUpdateOp::stfsu({{ Mem_sf = Fs_sf; }});
    //54: StoreDispOp::stfd({{ Mem_df = Fs; }});
    //55: StoreDispUpdateOp::stfdu({{ Mem_df = Fs; }});

    ##include "fp/storage_access/fp_ldst_disp.isa"

    58: decode DS_XO {
        0: LoadDispShiftOp::ld({{ Rt = Mem; }});
        1: LoadDispShiftUpdateOp::ldu({{ Rt = Mem; }});
        2: LoadDispShiftOp::lwa({{ Rt = Mem_sw; }});
    }

    59: decode A_XO {
        format FloatArithOp {
            ##include "fp/arith/sp_arith.isa"
            
            default: decode X_XO {
                ##include "fp/convert/convert_sp.isa"
            }
        }
    }

    60: decode XX2_XO {
        
        ##include "vsx/fp_arith/fp_arith_xx2.isa"
        ##include "vsx/convert/dp2int_xx2_xo.isa"
        ##include "vsx/convert/dp2sp_xx2_xo.isa"
        ##include "vsx/convert/int2fp_xx2_xo.isa"
        ##include "vsx/convert/round_to_int_xx2_xo.isa"
        ##include "vsx/convert/sp2dp_xx2_xo.isa"

        default: decode XX3_XO {
            
            ##include "vsx/fp_arith/fp_arith_xx3.isa"
            ##include "vsx/logical/logical_xx3_xo.isa"
            ##include "vsx/permute/perm_xx3_xo.isa"

            default: decode XX4_XO {
                ##include "vsx/permute/sel_xx4_xo.isa"
                // ###60: decode XX4_XO FloatArithOp###
                default: decode XX3_3_XO {                                               // wwf  [24, 28]
                    ##include "vsx/permute/perm_xx3_3xo.isa"
                    default:decode XX3RC_XO {
                        ##include "vsx/fp_comp/fp_comp_xx3rc_xo.isa"
                        default:decode XX2_XO {
                            format FloatArithOp {
                                170: xvtsqrtsp({{
                                    std::cout << "Running xvtsqrtsp in XX2_XO" << std::endl;			
                                }});
                            }
                        }
                    }
                }
            }
        }
    }

    62: decode DS_XO {
        0: StoreDispShiftOp::std({{ Mem = Rs; }});
        1: StoreDispShiftUpdateOp::stdu({{ Mem = Rs; }});
    }

    63: decode A_XO {
        ##include "fp/arith/dp_arith.isa"

        default: decode X_XO {
            ##include "fp/arith/misc.isa"
            ##include "fp/convert/convert_dp.isa"
            ##include "fp/cmp/fp_cmp.isa"
            ##include "fp/move/fp_regmove.isa"
        }
    }
}
