format IntArithOp {
    452: vsl({{                                            // wwf
        /*
            sh ← VSR[VRB+32].bit[125:127]
            t ← 1
            do i = 0 to 14
            t ← t & (VSR[VRB+32].byte[i].bit[5:7] = sh)
            end
            if t=1 then
            VSR[VRT+32] ← VSR[VRA+32] << sh
            else
            VSR[VRT+32] ← UNDEFINED
        */
        ThreadContext *tc = xc->tcBase();
        RegId vra_id(VecRegClass, VRA + 32);                
        RegId vrb_id(VecRegClass, VRB + 32);
        RegId vrt_id(VecRegClass, VRT + 32);                
        auto vra_reg = tc->readVecReg(vra_id);
        auto vra = vra_reg.as<uint64_t>();
        auto vrb_reg = tc->readVecReg(vrb_id);
        auto vrb = vrb_reg.as<uint8_t>();
        auto vrt_reg = tc->readVecReg(vrt_id);
        auto vrt = vrt_reg.as<uint64_t>();            
                        
        uint8_t sh = bits(vrb[15], 2, 0);
        uint64_t tmp, tmp_data[2];
        bool t = true, flag; 
        for(int i = 0; i < 15; i++)
        {
            flag = bits(vrb[i], 2, 0);
            t = t & flag;
            if(!flag)
            break;
        }
        if(t)
        {
            tmp_data[0] = vra[0];
            tmp_data[1] = vra[1];
            data_order_adjust((unsigned char*)&tmp_data[0], 8);
            data_order_adjust((unsigned char*)&tmp_data[1], 8);
            
            tmp = (tmp_data[1] >> (64-sh)) & mask(sh);
            vrt[0] = (tmp_data[0] << sh) | tmp;
            vrt[1] = tmp_data[1] << sh;
            
            data_order_adjust((unsigned char*)&vrt[0], 8);
            data_order_adjust((unsigned char*)&vrt[1], 8);
        }
        else                        // VSR[VRT+32] ← UNDEFINED
            inv_flag = true;
            
        //printf("vector:  sh= %d  t= %d  tmp=%x\n", sh, t, tmp); 
        //printf("vector:  Vt = %llx%llx\n",vrt[0], vrt[1]);
        
        tc->setVecReg(vrt_id, vrt_reg);
    }});

    708: vsr({{                                            // wwf
        /*
            sh ← VSR[VRB+32].bit[125:127]
            t ← 1
            do i = 0 to 14
            t ← t & (VSR[VRB+32].byte[i].bit[5:7] = sh)
            end
            if t=1 then
            VSR[VRT+32] ← CHOP128(EXTZ(VSR[VRA+32]) >> sh)
            else
            VSR[VRT+32] ← UNDEFINED
        */
        ThreadContext *tc = xc->tcBase();
        RegId vra_id(VecRegClass, VRA + 32);                
        RegId vrb_id(VecRegClass, VRB + 32);
        RegId vrt_id(VecRegClass, VRT + 32);                
        auto vra_reg = tc->readVecReg(vra_id);
        auto vra = vra_reg.as<uint64_t>();
        auto vrb_reg = tc->readVecReg(vrb_id);
        auto vrb = vrb_reg.as<uint8_t>();
        auto vrt_reg = tc->readVecReg(vrt_id);
        auto vrt = vrt_reg.as<uint64_t>();            
                        
        uint8_t sh = bits(vrb[15], 2, 0);
        uint64_t tmp, tmp_data[2];
        bool t = true, flag; 
        unsigned char *ppp;
        for(int i = 0; i < 15; i++)
        {
            flag = bits(vrb[i], 2, 0);
            t = t & flag;
            if(!flag)
            break;
        }
        if(t)
        {
            // EXTZ(VSR[VRA+32])     I think it is no sense.
            
            tmp_data[0] = vra[0];
            tmp_data[1] = vra[1];
            data_order_adjust((unsigned char*)&tmp_data[0], 8);
            data_order_adjust((unsigned char*)&tmp_data[1], 8);
            
            tmp = tmp_data[0] & mask(sh);
            vrt[1] = (tmp_data[1] >> sh) | (tmp << (64-sh));
            vrt[0] = tmp_data[0] >> sh;
            
            data_order_adjust((unsigned char*)&vrt[0], 8);
            data_order_adjust((unsigned char*)&vrt[1], 8);
            
            // CHOP128()
            ppp = (unsigned char*)&vrt[0];
            int i, tt;
            for(i=0; i < sh/8; i++)
            ppp[i] = 0x00;
            tt = sh - (sh/8)*8;
            ppp[i] = (ppp[i] << tt) >> tt;
        }
        else                        // VSR[VRT+32] ← UNDEFINED
            inv_flag = 1;
            
        //printf("vector:  sh= %d  t= %d  tmp=%x\n", sh, t, tmp); 
        //printf("vector:  Vt = %llx%llx\n",vrt[0], vrt[1]);
        
        tc->setVecReg(vrt_id, vrt_reg);
    }});

    1036: vslo({{                                            // wwf
        /*
            sh ← VSR[VRB+32].bit[121:124] << 3
            VSR[VRT+32] ← VSR[VRA+32] << sh
        */
        ThreadContext *tc = xc->tcBase();
        RegId vra_id(VecRegClass, VRA + 32);                
        RegId vrb_id(VecRegClass, VRB + 32);
        RegId vrt_id(VecRegClass, VRT + 32);                
        auto vra_reg = tc->readVecReg(vra_id);
        auto vra = vra_reg.as<uint64_t>();
        auto vrb_reg = tc->readVecReg(vrb_id);
        auto vrb = vrb_reg.as<uint8_t>();
        auto vrt_reg = tc->readVecReg(vrt_id);
        auto vrt = vrt_reg.as<uint64_t>();            
                        
        uint8_t sh = bits(vrb[15], 6, 3) << 3;
        uint64_t tmp, tmp_data[2];
        tmp_data[0] = vra[0];
        tmp_data[1] = vra[1];
        data_order_adjust((unsigned char*)&tmp_data[0], 8);
        data_order_adjust((unsigned char*)&tmp_data[1], 8);
        
        if(sh < 64)
        {
            tmp = (tmp_data[1] >> (64-sh)) & mask(sh);
            vrt[0] = (tmp_data[0] << sh) | tmp;
            vrt[1] = tmp_data[1] << sh;
        }
        else
        {
            int sh_t = sh - 64;
            vrt[1] = 0x00;
            vrt[0] = tmp_data[1] << sh_t;
        }
            
        data_order_adjust((unsigned char*)&vrt[0], 8);
        data_order_adjust((unsigned char*)&vrt[1], 8);
                            
        //printf("vector:  sh= %d  tmp=%x\n", sh, tmp); 
        //printf("vector:  Vt = %llx%llx\n",vrt[0], vrt[1]);
        
        tc->setVecReg(vrt_id, vrt_reg);
    }});

    1100: vsro({{                                            // wwf
        /*
            sh ← VSR[VRB+32].bit[121:124] << 3
            VSR[VRT+32] ← VSR[VRA+32] >> sh
        */
        ThreadContext *tc = xc->tcBase();
        RegId vra_id(VecRegClass, VRA + 32);                
        RegId vrb_id(VecRegClass, VRB + 32);
        RegId vrt_id(VecRegClass, VRT + 32);                
        auto vra_reg = tc->readVecReg(vra_id);
        auto vra = vra_reg.as<uint64_t>();
        auto vrb_reg = tc->readVecReg(vrb_id);
        auto vrb = vrb_reg.as<uint8_t>();
        auto vrt_reg = tc->readVecReg(vrt_id);
        auto vrt = vrt_reg.as<uint64_t>();            
                        
        uint8_t sh = bits(vrb[15], 6, 3) << 3;
        uint64_t tmp, tmp_data[2];
        tmp_data[0] = vra[0];
        tmp_data[1] = vra[1];
        data_order_adjust((unsigned char*)&tmp_data[0], 8);
        data_order_adjust((unsigned char*)&tmp_data[1], 8);
        
        if(sh < 64)
        {
            tmp = tmp_data[0] & mask(sh);
            vrt[1] = (tmp_data[1] >> sh) | (tmp << (64-sh));
            vrt[0] = tmp_data[0] >> sh;
        }
        else
        {
            int sh_t = sh - 64;
            vrt[0] = 0x00;
            vrt[1] = tmp_data[0] >> sh_t;
        }
            
        data_order_adjust((unsigned char*)&vrt[0], 8);
        data_order_adjust((unsigned char*)&vrt[1], 8);
                            
        //printf("vector:  sh= %d  tmp=%x\n", sh, tmp); 
        //printf("vector:  Vt = %llx%llx\n",vrt[0], vrt[1]);
        
        tc->setVecReg(vrt_id, vrt_reg);
    }});

    1860: vslv({{                                            // wwf
        /*
            vsrc.byte[0:15] ← VSR[VRA+32]
            vsrc.byte[16] ← 0x00
            do i = 0 to 15
            sh ← VSR[VRB+32].byte[i].bit[5:7]
            VSR[VRT+32].byte[i] ← vsrc.byte[i:i+1].bit[sh:sh+7]
            end
        */
        ThreadContext *tc = xc->tcBase();
        RegId vra_id(VecRegClass, VRA + 32);                
        RegId vrb_id(VecRegClass, VRB + 32);
        RegId vrt_id(VecRegClass, VRT + 32);                
        auto vra_reg = tc->readVecReg(vra_id);
        auto vra = vra_reg.as<uint64_t>();
        auto vrb_reg = tc->readVecReg(vrb_id);
        auto vrb = vrb_reg.as<uint8_t>();
        auto vrt_reg = tc->readVecReg(vrt_id);
        auto vrt = vrt_reg.as<uint8_t>();            
        
        uint8_t vsrc[18], sh, tmp_data[2];
        uint64_t *p_64 = (uint64_t*)&vsrc[0];
        uint16_t *p_16;
        p_64[0] = vra[0];
        p_64[1] = vra[1];
        vsrc[16] = 0x00;
        
        for(int i=0; i < 16; i++)
        {
            sh = bits(vrb[i], 2, 0);
            tmp_data[0] = vsrc[i+1];             // vsrc.byte[i:i+1].bit[sh:sh+7]
            tmp_data[1] = vsrc[i];                  
            p_16 = (uint16_t*)&tmp_data[0];
            vrt[i] = bits(*p_16, 15-sh, 15-(sh+7));
                            
            //printf("vector: %d  vrb[i]=%x  sh= %d  tmp=%x  vrt[i]=%x  [sh:sh+7]\n", i, vrb[i], sh, *p_16, vrt[i]);
        }
        
        tc->setVecReg(vrt_id, vrt_reg);
    }});

    1796: vsrv({{                                            // wwf
        /*
            vsrc.byte[0] ← 0x00
            vsrc.byte[1:16] ← VSR[VRA+32]
            do i = 0 to 15
            sh ← VSR[VRB+32].byte[i].bit[5:7]
            VSR[VRT+32].byte[i] ← vsrc.byte[i:i+1].bit[8-sh:15-sh]
            end
        */
        ThreadContext *tc = xc->tcBase();
        RegId vra_id(VecRegClass, VRA + 32);                
        RegId vrb_id(VecRegClass, VRB + 32);
        RegId vrt_id(VecRegClass, VRT + 32);                
        auto vra_reg = tc->readVecReg(vra_id);
        auto vra = vra_reg.as<uint64_t>();
        auto vrb_reg = tc->readVecReg(vrb_id);
        auto vrb = vrb_reg.as<uint8_t>();
        auto vrt_reg = tc->readVecReg(vrt_id);
        auto vrt = vrt_reg.as<uint8_t>();            
        
        uint8_t vsrc[18], sh, tmp_data[2];
        uint64_t *p_64 = (uint64_t*)&vsrc[1];
        uint16_t *p_16;
        p_64[0] = vra[0];
        p_64[1] = vra[1];
        vsrc[0] = 0x00;
        
        for(int i=0; i < 16; i++)
        {
            sh = bits(vrb[i], 2, 0);
            tmp_data[0] = vsrc[i+1];             // vsrc.byte[i:i+1].bit[8-sh:15-sh]
            tmp_data[1] = vsrc[i];
            p_16 = (uint16_t*)&tmp_data[0];
            vrt[i] = bits(*p_16, 15-(8-sh), 15-(15-sh));
                            
            //printf("vector: %d  vrb[i]=%x  sh= %d  tmp=%x  vrt[i]=%x  [8-sh:15-sh]\n", i, vrb[i], sh, *p_16, vrt[i]);
        }
        
        tc->setVecReg(vrt_id, vrt_reg);
    }});
}